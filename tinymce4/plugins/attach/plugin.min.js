(function () {
var image = (function (domGlobals) {
    'use strict';

    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');
    var selection, dom, selectedElm, anchorElm, initialText, onlyText;
    function isOnlyTextSelected(anchorElm) {
      var html = selection.getContent();

      // Partial html and not a fully selected anchor element
      if (/</.test(html) && (!/^<a [^>]+>[^<]+<\/a>$/.test(html) || html.indexOf('href=') == -1)) {
        return false;
      }

      if (anchorElm) {
        var nodes = anchorElm.childNodes, i;

        if (nodes.length === 0) {
          return false;
        }

        for (i = nodes.length - 1; i >= 0; i--) {
          if (nodes[i].nodeType != 3) {
            return false;
          }
        }
      }

      return true;
    }

    var hasDescription = function (editor) {
      return editor.settings.image_description === false ? false : true;
    };
    var hasUploadUrl = function (editor) {
      return editor.getParam('images_upload_url', false);
    };
    var hasUploadHandler = function (editor) {
      return editor.getParam('images_upload_handler', false);
    };
    var getUploadUrl = function (editor) {
      return editor.getParam('images_upload_url');
    };
    var getUploadHandler = function (editor) {
      return editor.getParam('images_upload_handler');
    };
    var getUploadBasePath = function (editor) {
      return editor.getParam('images_upload_base_path');
    };
    var getUploadCredentials = function (editor) {
      return editor.getParam('images_upload_credentials');
    };
    var Settings = {
      hasDescription: hasDescription,
      hasUploadUrl: hasUploadUrl,
      hasUploadHandler: hasUploadHandler,
      getUploadUrl: getUploadUrl,
      getUploadHandler: getUploadHandler,
      getUploadBasePath: getUploadBasePath,
      getUploadCredentials: getUploadCredentials
    };

    var Global = typeof domGlobals.window !== 'undefined' ? domGlobals.window : Function('return this;')();

    var path = function (parts, scope) {
      var o = scope !== undefined && scope !== null ? scope : Global;
      for (var i = 0; i < parts.length && o !== undefined && o !== null; ++i)
        o = o[parts[i]];
      return o;
    };
    var resolve = function (p, scope) {
      var parts = p.split('.');
      return path(parts, scope);
    };

    var unsafe = function (name, scope) {
      return resolve(name, scope);
    };
    var getOrDie = function (name, scope) {
      var actual = unsafe(name, scope);
      if (actual === undefined || actual === null)
        throw name + ' not available on this browser';
      return actual;
    };
    var Global$1 = { getOrDie: getOrDie };

    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Promise');

    var global$2 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var onBeforeCall = function (evt) {
      evt.meta = evt.control.rootControl.toJSON();
    };
    function urlChange(e) {
      var alt = this.parent().parent().find('#alt')[0];
      if (alt.value() == '') {
        var str = this.value();
        alt.value(str.substring(str.lastIndexOf('/') + 1));
      }
    }
    var getGeneralItems = function (editor) {
      var generalFormItems = [
        {
          name: 'src',
          type: 'filepicker',
          filetype: 'file',
          size: 40,
          label: 'Source',
          autofocus: true,
          onchange: urlChange,
          onbeforecall: onBeforeCall
        }
      ];
      if (Settings.hasDescription(editor)) {
        generalFormItems.push({
          name: 'alt',
          type: 'textbox',
          label: 'File description',
          size: 40
        });
      }

      return generalFormItems;
    };
    var makeTab$1 = function (editor) {
      return {
        title: 'General',
        type: 'form',
        items: getGeneralItems(editor)
      };
    };
    var MainTab = {
      makeTab: makeTab$1,
      getGeneralItems: getGeneralItems
    };


    var global$5 = tinymce.util.Tools.resolve('tinymce.ui.Factory');

    function XMLHttpRequest () {
      var f = Global$1.getOrDie('XMLHttpRequest');
      return new f();
    }

    var noop = function () {
    };
    var pathJoin = function (path1, path2) {
      if (path1) {
        return path1.replace(/\/$/, '') + '/' + path2.replace(/^\//, '');
      }
      return path2;
    };
    function Uploader (settings) {
      var defaultHandler = function (blobInfo, success, failure, progress) {
        var xhr, formData;
        xhr = XMLHttpRequest();
        xhr.open('POST', settings.url);
        xhr.withCredentials = settings.credentials;
        xhr.upload.onprogress = function (e) {
          progress(e.loaded / e.total * 100);
        };
        xhr.onerror = function () {
          failure('File upload failed due to a XHR Transport error. Code: ' + xhr.status);
        };
        xhr.onload = function () {
          var json;
          if (xhr.status < 200 || xhr.status >= 300) {
            failure('HTTP Error: ' + xhr.status);
            return;
          }
          json = JSON.parse(xhr.responseText);
          if (!json || typeof json.location !== 'string') {
            failure('Invalid JSON: ' + xhr.responseText);
            return;
          }
          success(pathJoin(settings.basePath, json.location));
        };
        formData = new domGlobals.FormData();
        formData.append('file', blobInfo.blob, blobInfo.name);
        formData.append('type', 'attach');
        xhr.send(formData);
      };
      var uploadBlob = function (blobInfo, handler) {
        return new global$1(function (resolve, reject) {
          try {
            handler(blobInfo, resolve, reject, noop);
          } catch (ex) {
            reject(ex.message);
          }
        });
      };
      var isDefaultHandler = function (handler) {
        return handler === defaultHandler;
      };
      var upload = function (blobInfo) {
        return !settings.url && isDefaultHandler(settings.handler) ? global$1.reject('Upload url missing from the settings.') : uploadBlob(blobInfo, settings.handler);
      };
      settings = global$2.extend({
        credentials: false,
        handler: defaultHandler
      }, settings);
      return { upload: upload };
    }

    var onFileInput = function (editor) {
      return function (evt) {
        var Throbber = global$5.get('Throbber');
        var rootControl = evt.control.rootControl;
        var throbber = new Throbber(rootControl.getEl());
        var file = evt.control.value();
        var uploader = Uploader({
          url: Settings.getUploadUrl(editor),
          basePath: Settings.getUploadBasePath(editor),
          credentials: Settings.getUploadCredentials(editor),
          handler: Settings.getUploadHandler(editor)
        });
        var finalize = function () {
          throbber.hide();
        };
        throbber.show();
        var blobInfo = {
          blob: file,
          name: file.name ? file.name : null
        };
        return uploader.upload(blobInfo).then(function (url) {
          var src = rootControl.find('#src');
          src.value(url);
          rootControl.find('tabpanel')[0].activateTab(0);
          src.fire('change');
          finalize();
          return url;
        });
      };
    };
    var makeTab$2 = function (editor) {
      return {
        title: 'Upload',
        type: 'form',
        layout: 'flex',
        direction: 'column',
        align: 'stretch',
        padding: '20 20 20 20',
        items: [
          {
            type: 'container',
            layout: 'flex',
            direction: 'column',
            align: 'center',
            spacing: 10,
            items: [
              {
                text: 'Browse for a file',
                type: 'browsebutton',
                onchange: onFileInput(editor)
              },
              {
                text: 'OR',
                type: 'label'
              }
            ]
          },
          {
            text: 'Drop a file here',
            type: 'dropzone',
            height: 100,
            onchange: onFileInput(editor)
          }
        ]
      };
    };
    var UploadTab = { makeTab: makeTab$2 };

    function onSubmit(editor,e) {
      /*eslint dot-notation: 0*/
      var href;

      href = e.data.src;

      function insertLink() {
        var linkAttrs = {
          href: href,
          target: '_blank',
          "class": 'attach'
        };

        if (anchorElm) {
          editor.focus();

          if (onlyText && e.data.alt != initialText) {
            if ("innerText" in anchorElm) {
              anchorElm.innerText = e.data.alt;
            } else {
              anchorElm.textContent = e.data.alt;
            }
          }

          dom.setAttribs(anchorElm, linkAttrs);

          selection.select(anchorElm);
          editor.undoManager.add();
        } else {
          if (onlyText) {
            editor.insertContent(dom.createHTML('a', linkAttrs, dom.encode(e.data.alt)));
          } else {
            editor.execCommand('mceInsertLink', false, linkAttrs);
          }
        }
      }

      if (!href) {
        editor.execCommand('unlink');
        return;
      }

      insertLink();
    }

    function curry(fn) {
      var initialArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        initialArgs[_i - 1] = arguments[_i];
      }
      return function () {
        var restArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          restArgs[_i] = arguments[_i];
        }
        var all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
      };
    }

    function readFileDataFromSelection(editor) {
      var data = {}, selection = editor.selection, dom = editor.dom, selectedElm, anchorElm;
  		selectedElm = selection.getNode();
  		anchorElm = dom.getParent(selectedElm, 'a[href].attach');

      data.alt = anchorElm ? (anchorElm.innerText || anchorElm.textContent) : selection.getContent({format: 'text'});
      data.src = anchorElm ? dom.getAttrib(anchorElm, 'href') : '';
      return data;
    }
    function Dialog (editor) {
      function showDialog() {
        selection = editor.selection;
        dom = editor.dom;
        selectedElm = selection.getNode();
    		anchorElm = dom.getParent(selectedElm, 'a[href].attach');
        onlyText = isOnlyTextSelected(anchorElm);

        var data = readFileDataFromSelection(editor);
        var win;
        if (Settings.hasUploadUrl(editor) || Settings.hasUploadHandler(editor)) {
          var body = [MainTab.makeTab(editor)];
          if (Settings.hasUploadUrl(editor) || Settings.hasUploadHandler(editor)) {
            body.push(UploadTab.makeTab(editor));
          }
          win = editor.windowManager.open({
            title: 'Attach File',
            data: data,
            bodyType: 'tabpanel',
            body: body,
            onSubmit: curry(onSubmit, editor)
          });
        } else {
          win = editor.windowManager.open({
            title: 'Attach File',
            data: data,
            body: MainTab.getGeneralItems(editor),
            onSubmit: curry(onSubmit, editor)
          });
        }
      }
      function open() {
        showDialog();
      }
      return { open: open };
    }

    var register = function (editor) {
      editor.addCommand('mceAttach', Dialog(editor).open);
    };
    var Commands = { register: register };

    var register$1 = function (editor) {
      editor.addButton('attach', {
        icon: 'attach',
    		tooltip: 'Attach File',
        onclick: Dialog(editor).open,
        stateSelector: 'a[href].attach'
      });

      editor.addMenuItem('attach', {
        icon: 'attach',
    		text: 'Attach File',
        onclick: Dialog(editor).open,
        stateSelector: 'a[href].attach',
        context: 'insert',
        prependToContext: true
      });
    };
    var Buttons = { register: register$1 };

    global.add('attach', function (editor) {
      Buttons.register(editor);
      Commands.register(editor);
    });
    function Plugin () {
    }

    return Plugin;

}(window));
})();
