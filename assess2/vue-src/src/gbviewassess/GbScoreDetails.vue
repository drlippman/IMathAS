<template>
  <div class="scoredetails">
    <menu-button
      v-if="canedit"
      class = "floatright"
      :options = "moreOptions"
      position = "right"
      nobutton = "true"
      noarrow = "true"
      :id = "'qmore' + qn"
    >
      <template v-slot:button>
        <icons name="more" size="medium"/>
      </template>
    </menu-button>
    <div v-if="canedit || (qdata.hasOwnProperty('score') && qdata.score !== 'N/A')">
      {{ $t('gradebook.score') }}:
      <span
        v-for="(poss,i) in partPoss"
        :key="i"
      >
        <input
          v-if="canedit && !isPractice"
          type="text"
          size="4"
          :id="'scorebox' + qn + (partPoss.length > 1 ? '-' + i : '')"
          v-model="curScores[i]"
          @input="updateScore(i, $event)"
        /><span v-else>{{ curScores[i] }}</span>/{{ poss }}
        <button
          v-if="canedit && !isPractice && qdata.rubric > 0"
          class="plain nopad"
          @click="showRubric(i)"
        >
          <icons name="clipboard" alt="icons.rubric" size="small" />
        </button>
      </span>
      <button
        v-if="canedit && !isPractice"
        type="button"
        @click="allFull"
        class="slim"
      >
        {{ fullCreditLabel }}
      </button>
      <button
        v-if="canedit && !isPractice && showfeedback === false"
        type="button"
        class="slim"
        @click="revealFeedback"
      >
        {{ $t('gradebook.add_feedback') }}
      </button>
    </div>
    <gb-feedback
      :show="showfeedback"
      :canedit = "canedit"
      :useeditor = "useEditor"
      ref = "fbbox"
      :qn = "qn"
      :value = "qdata.feedback"
      @update = "updateFeedback"
    />

    <div v-if="showfull">
      <span v-if="qdata.timeactive.total > 0">
        {{ $t('gradebook.time_on_version') }}:
        {{ timeSpent }}
      </span>
      <button
        v-if="maxTry > 1"
        type="button"
        class="slim"
        @click="showAllTries = !showAllTries"
      >
        {{ $t('gradebook.show_tries') }}
      </button>
      <button
        v-if="hasPenalties"
        type="button"
        class="slim"
        @click="showPenalties = !showPenalties"
      >
        {{ $t('gradebook.show_penalties') }}
      </button>
    </div>
    <gb-all-tries
      v-if="showAllTries"
      :tries="qdata.other_tries"
      :qn="qn"
    />
    <gb-penalties
      v-if="showPenalties"
      :parts="qdata.parts"
      :submitby="submitby"
    />
    <div v-if="canedit && showfull && qHelps.length > 0">
      {{ $t('gradebook.had_help') }}:
      <a v-for="(help,idx) in qHelps"
        :key="idx"
        :href="help.url"
        target="_blank"
      >{{ help.title }}</a>
    </div>
  </div>
</template>

<script>
import { store, actions } from './gbstore';
import GbAllTries from '@/gbviewassess/GbAllTries';
import GbPenalties from '@/gbviewassess/GbPenalties';
import Icons from '@/components/widgets/Icons';
import MenuButton from '@/components/widgets/MenuButton';
import GbFeedback from '@/gbviewassess/GbFeedback';

export default {
  name: 'GbScoreDetails',
  props: ['qdata', 'qn', 'canedit', 'showfull'],
  components: {
    GbAllTries,
    GbPenalties,
    MenuButton,
    Icons,
    GbFeedback
  },
  data: function () {
    return {
      curScores: false,
      showfeedback: false,
      showAllTries: false,
      showPenalties: false
    };
  },
  computed: {
    answeights () {
      if (!this.qdata.answeights || this.qdata.singlescore) { // if answeights not generated yet
        return [1];
      } else {
        let answeights = this.qdata.answeights.map(x => parseFloat(x));
        let answeightTot = answeights.reduce((a, c) => a + c);
        return answeights.map(x => x / answeightTot);
      }
    },
    partPoss () {
      var out = [];
      for (let i = 0; i < this.answeights.length; i++) {
        out[i] = Math.round(1000 * this.qdata.points_possible * this.answeights[i]) / 1000;
      }
      return out;
    },
    initScores () {
      var out = [];
      for (let i = 0; i < this.answeights.length; i++) {
        if (this.qdata.singlescore) {
          out.push(this.qdata.score);
        } else if (this.qdata.scoreoverride && typeof this.qdata.scoreoverride !== 'object') {
          // handle the case of a single override
          let partscore = this.qdata.scoreoverride * this.answeights[i] * this.qdata.points_possible;
          partscore = Math.round(1000 * partscore) / 1000;
          out.push(partscore);
        } else if (this.qdata.scoreoverride && this.qdata.scoreoverride.hasOwnProperty(i)) {
          if (this.qdata.parts[i] && this.qdata.parts[i].points_possible) {
            out.push(Math.round(1000 * this.qdata.scoreoverride[i] * this.qdata.parts[i].points_possible) / 1000);
          } else {
            out.push(Math.round(1000 * this.qdata.scoreoverride[i] * this.answeights[i] * this.qdata.points_possible) / 1000);
          }
        } else if (this.maxTry === 0 || !this.qdata.parts[i].hasOwnProperty('score')) { // not attempted or not showing
          out.push('N/A');
        } else {
          out.push(this.qdata.parts[i].score);
        }
      }
      return out;
    },
    fullCreditLabel () {
      if (this.answeights.length > 1) {
        return this.$t('gradebook.full_credit_parts');
      } else {
        return this.$t('gradebook.full_credit');
      }
    },
    timeSpent () {
      let out = Math.round(10 * this.qdata.timeactive.total / 60) / 10 + ' ' + this.$t('gradebook.minutes');
      // TODO: Add per-try average?
      return out;
    },
    useEditor () {
      return (typeof window.tinyMCE !== 'undefined');
    },
    isPractice () {
      return store.ispractice;
    },
    isLastVersion () {
      let avercnt = store.assessInfo.assess_versions.length - 1;
      if (store.assessInfo.has_practice) {
        avercnt--;
      }
      return (store.curAver === avercnt);
    },
    maxTry () {
      let maxtry = 0;
      for (let i = 0; i < this.qdata.parts.length; i++) {
        if (this.qdata.parts[i] && this.qdata.parts[i].try) {
          if (this.qdata.parts[i].try > maxtry) {
            maxtry = this.qdata.parts[i].try;
          }
        }
      }
      return maxtry;
    },
    questionEditUrl () {
      let qs = 'id=' + this.qdata.qsetid + '&cid=' + store.cid;
      qs += '&aid=' + store.aid + '&qid=' + this.qdata.qid;
      return store.APIbase + '../course/moddataset.php?' + qs;
    },
    questionErrorUrl () {
      if (store.assessInfo.qerror_cid) {
        let quoteq = '0-' + this.qdata.qsetid + '-' + this.qdata.seed +
          '-reperr-' + store.assessInfo.ver;
        let qs = 'add=new&cid=' + store.assessInfo.qerror_cid +
          '&quoteq=' + quoteq + '&to=' + this.qdata.qowner +
          '&title=Problem%20with%20question%20id%20' +
          this.qdata.qsetid;
        return store.APIbase + '../msgs/msglist.php?' + qs;
      } else {
        return '';
      }
    },
    useInMsg () {
      // TODO
      let quoteq = this.qn + '-' + this.qdata.qsetid + '-' + this.qdata.seed +
        '-' + store.aid + '-' + store.assessInfo.ver;
      let qs = 'add=new&cid=' + store.cid +
        '&quoteq=' + quoteq + '&to=' + store.uid;
      return store.APIbase + '../msgs/msglist.php?' + qs;
      // TODO: get GB to work for this.
      // window.GB_show(this.$t('gradebook.send_msg'),
      //  store.APIbase + '../msgs/msglist.php?'+qs, 800, 'auto');
    },
    moreOptions () {
      let out = [
        {
          label: this.$t('gradebook.use_in_msg'),
          link: this.useInMsg
        },
        {
          label: this.$t('gradebook.view_edit') + ' ID ' + this.qdata.qsetid + ' Seed ' + this.qdata.seed,
          link: this.questionEditUrl
        },
        {
          label: this.$t('gradebook.msg_owner'),
          link: this.questionErrorUrl
        }
      ];
      if (!this.isPractice && this.isLastVersion) {
        out.push({
          label: this.$t('gradebook.clear_qwork'),
          onclick: () => this.clearWork()
        });
      }
      return out;
    },
    hasPenalties () {
      for (let pn = 0; pn < this.qdata.parts.length; pn++) {
        if (this.qdata.parts[pn].hasOwnProperty('penalties') &&
          this.qdata.parts[pn].penalties.length > 0
        ) {
          return true;
        }
      }
      return false;
    },
    submitby () {
      return store.assessInfo.submitby;
    },
    qHelps () {
      if (this.qdata.jsparams) {
        let helps = this.qdata.jsparams.helps;
        for (let i in helps) {
          if (helps[i].label === 'video') {
            helps[i].icon = 'video';
            helps[i].title = this.$t('helps.video');
          } else if (helps[i].label === 'read') {
            helps[i].icon = 'file';
            helps[i].title = this.$t('helps.read');
          } else if (helps[i].label === 'ex') {
            helps[i].icon = 'file';
            helps[i].title = this.$t('helps.written_example');
          } else {
            helps[i].icon = 'file';
            helps[i].title = helps[i].label;
          }
        }
        return helps;
      } else {
        return [];
      }
    }
  },
  methods: {
    updateScore (pn, evt) {
      let partposs = this.qdata.points_possible * this.answeights[pn];
      actions.setScoreOverride(this.qn, pn, this.curScores[pn] / partposs);
    },
    revealFeedback () {
      this.showfeedback = true;
      this.$nextTick(() => this.$refs.fbbox.focus());
    },
    updateFeedback (val) {
      actions.setFeedback(this.qn, val);
    },
    allFull () {
      for (let i = 0; i < this.answeights.length; i++) {
        this.$set(this.curScores, i, this.partPoss[i]);
        actions.setScoreOverride(this.qn, i, this.curScores[i] / this.partPoss[i]);
      }
    },
    clearWork () {
      store.clearAttempts.type = 'qver';
      store.clearAttempts.qn = this.qn;
      store.clearAttempts.show = true;
    },
    initCurScores () {
      this.$set(this, 'curScores', this.initScores);
      this.showfeedback = (this.qdata.feedback !== null && this.qdata.feedback.length > 0);
    },
    showRubric (pn) {
      if (!window.imasrubrics) {
        window.imasrubrics = store.assessInfo['rubrics'];
      }
      this.showfeedback = true;
      window.imasrubric_show(
        this.qdata.rubric,
        this.qdata.points_possible,
        'scorebox' + this.qn + (this.partPoss.length > 1 ? '-' + pn : ''),
        'fb' + this.qn,
        this.qn,
        600
      );
    }
  },
  mounted () {
    this.initCurScores();
  },
  watch: {
    qdata: function (newVal, oldVal) {
      this.initCurScores();
    }
  }
};
</script>

<style>
.scoredetails {
  border-top: 1px solid #ccc;
  padding: 8px;
}
</style>
