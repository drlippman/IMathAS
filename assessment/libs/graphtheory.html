<html><body>
<h1>Macro Library graphtheory</h1>
A library of graph theory and scheduling functions.  Version 1.1, April 3, 2012
<BR>
<BR>Most graphing functions in this library use an options array.  Here are the
<BR>common options - specific functions will mention other options.
<BR>  options['width'] = width of output, in pixels.  Defaults to 300.
<BR>  options['height'] = height of output, in pixels.  Defaults to 300.
<BR>  options['digraph'] = true/false.  If true, g[i][j] > 0 means i leads to j
<BR>  options['useweights'] = true/false.  If true, g[i][j] used as weight
<BR>  options['labels'] = "letters" or array of labels.  If "letters", letters
<BR>    A-Z used for labels.  If array, label[i] used for vertex g[i]
<BR>  options['weightoffset'] = position (0-1) along edge where weights should go
<BR>  options['connected'] = true/false.  When randomizing graphs, whether you
<BR>    want to force the result to be connected.  If false for a tree, this
<BR>    forces a disconnected graph
<BR>  options['randweights'] = max or array(min,max).  Randomizes weights of edges
<BR>  options['randedges'] = probability (0-1).  Randomly keeps edges of original 
<BR>    graph with given probability.
<BR>  options['tree'] = true.  Creates a minimum cost spanning tree from the original graph
<BR>  options['labelposition'] = "above","below","right","left","aboveright",etc.
<BR>    position of vertex labels.  
<BR><ul>
<li><a href="#graphcircleladder">graphcircleladder</a></li>
<li><a href="#graphnestedpolygons">graphnestedpolygons</a></li>
<li><a href="#graphcircle">graphcircle</a></li>
<li><a href="#graphcircledstar">graphcircledstar</a></li>
<li><a href="#graphbipartite">graphbipartite</a></li>
<li><a href="#graphgrid">graphgrid</a></li>
<li><a href="#graphrandom">graphrandom</a></li>
<li><a href="#graphemptygraph">graphemptygraph</a></li>
<li><a href="#graphdijkstra">graphdijkstra</a></li>
<li><a href="#graphkruskal">graphkruskal</a></li>
<li><a href="#graphrepeatednearestneighbor">graphrepeatednearestneighbor</a></li>
<li><a href="#graphnearestneighbor">graphnearestneighbor</a></li>
<li><a href="#graphsortededges">graphsortededges</a></li>
<li><a href="#graphsequenceeuleredgedups">graphsequenceeuleredgedups</a></li>
<li><a href="#graphsequenceishamiltonian">graphsequenceishamiltonian</a></li>
<li><a href="#graphgetpathlength">graphgetpathlength</a></li>
<li><a href="#graphshortestpath">graphshortestpath</a></li>
<li><a href="#graphcircuittoarray">graphcircuittoarray</a></li>
<li><a href="#graphcircuittostringans">graphcircuittostringans</a></li>
<li><a href="#graphgetedges">graphgetedges</a></li>
<li><a href="#graphgetedgesarray">graphgetedgesarray</a></li>
<li><a href="#graphgettotalcost">graphgettotalcost</a></li>
<li><a href="#graphadjacencytoprereqs">graphadjacencytoprereqs</a></li>
<li><a href="#graphprereqtable">graphprereqtable</a></li>
<li><a href="#graphadjacencytoincidence">graphadjacencytoincidence</a></li>
<li><a href="#graphincidencetoadjacency">graphincidencetoadjacency</a></li>
<li><a href="#graphgetvalence">graphgetvalence</a></li>
<li><a href="#graphmakesymmetric">graphmakesymmetric</a></li>
<li><a href="#graphisconnected">graphisconnected</a></li>
<li><a href="#graphmaketable">graphmaketable</a></li>
<li><a href="#graphspringlayout">graphspringlayout</a></li>
<li><a href="#graphcirclelayout">graphcirclelayout</a></li>
<li><a href="#graphcircledstarlayout">graphcircledstarlayout</a></li>
<li><a href="#graphgridlayout">graphgridlayout</a></li>
<li><a href="#graphpathlayout">graphpathlayout</a></li>
<li><a href="#graphprocessoptions">graphprocessoptions</a></li>
<li><a href="#graphdrawit">graphdrawit</a></li>
<li><a href="#graphcomparecircuits">graphcomparecircuits</a></li>
<li><a href="#graphrandomgridschedule">graphrandomgridschedule</a></li>
<li><a href="#graphdecreasingtimelist">graphdecreasingtimelist</a></li>
<li><a href="#graphcriticaltimelist">graphcriticaltimelist</a></li>
<li><a href="#graphbackflow">graphbackflow</a></li>
<li><a href="#graphlistprocessing">graphlistprocessing</a></li>
<li><a href="#graphscheduletaskinfo">graphscheduletaskinfo</a></li>
<li><a href="#graphschedulecompletion">graphschedulecompletion</a></li>
<li><a href="#graphscheduleidle">graphscheduleidle</a></li>
<li><a href="#graphscheduleproctasks">graphscheduleproctasks</a></li>
<li><a href="#graphdrawschedule">graphdrawschedule</a></li>
<li><a href="#graphschedulelayout">graphschedulelayout</a></li>
<li><a href="#graphschedulemultchoice">graphschedulemultchoice</a></li>
</ul>
<h3><a name="graphcircleladder">graphcircleladder</a></h3>
/graphcircleladder(n,m,[options])
<BR>draws a circular ladder graph
<BR>n vertices around a circle
<BR>m concentric circles
<BR>connected around circle and between circles
<BR>returns array(pic,g)
<BR><h3><a name="graphnestedpolygons">graphnestedpolygons</a></h3>
graphnestedpolygons(n,m,[options])
<BR>draws a graph of offset nested polygons
<BR>n vertices around a polygon
<BR>m concentric polygons
<BR>vertices of inner polygon touches midpoint of outer polygon
<BR>returns array(pic,g)
<BR><h3><a name="graphcircle">graphcircle</a></h3>
graphcircle(n,[options])
<BR>draws a complete graph with a circular layout
<BR>with n vertices
<BR>returns array(pic,g)
<BR><h3><a name="graphcircledstar">graphcircledstar</a></h3>
graphcircledstar(n,[options])
<BR>draws n vertices in a circle, plus 1 vertex in the middle
<BR>vertices are connected along the circle, plus all
<BR>connected to the center vertex
<BR>returns array(pic,g)
<BR><h3><a name="graphbipartite">graphbipartite</a></h3>
graphbipartite(n,[options])
<BR>draws a complete bipartite graph (every vertex on left is 
<BR>connected to every vertex on the right)
<BR>with n vertices in the first column, m in the second
<BR>returns array(pic,g)
<BR><h3><a name="graphgrid">graphgrid</a></h3>
graphgrid(n, m, [options])
<BR>draws a n by m grid of vertices.
<BR>returns array(pic,g)
<BR><h3><a name="graphrandom">graphrandom</a></h3>
graphrandom(n,[options])
<BR>draws a randomly spring laid out graph with n vertices. 
<BR><h3><a name="graphemptygraph">graphemptygraph</a></h3>
graphemptygraph(n)
<BR>creates an empty graph matrix, nxn
<BR><h3><a name="graphdijkstra">graphdijkstra</a></h3>
graphdijkstra(g,[dest]) 
<BR>computes dijkstras algorithm on the graph g
<BR>g is a 2-dimensional matrix
<BR>g[i][j]  &gt; 0 if vertexes i and j are connected
<BR>if dest vertex not set then
<BR>the last vertex will be used as the destination vertex
<BR>returns array(dist,next) where
<BR>dist[i] is the shortest dist to end, and
<BR>next[i] is the vertex next closest to the end
<BR><h3><a name="graphkruskal">graphkruskal</a></h3>
graphkruskal(g) 
<BR>return a minimum cost spanning tree graph from graph g
<BR><h3><a name="graphrepeatednearestneighbor">graphrepeatednearestneighbor</a></h3>
graphrepeatednearestneighbor(g, [multi])
<BR>returns an array (graph,mincostarr), where graph is the
<BR>hamiltonian circuit graph using repeated nearest neighbor, and mincostarr
<BR>is an array of starting vertex indices that gave that graph.
<BR>If multi is set to true, an array of graphs is returned rather than just one
<BR><h3><a name="graphnearestneighbor">graphnearestneighbor</a></h3>
graphnearestneighbor(g,start)
<BR>returns a hamiltonian circuit graph using nearest neighbor
<BR>starting at vertex start
<BR><h3><a name="graphsortededges">graphsortededges</a></h3>
graphsortededges(g) 
<BR>returns a hamiltonian circuit graph using sorted edges
<BR><h3><a name="graphsequenceeuleredgedups">graphsequenceeuleredgedups</a></h3>
function graphsequenceeuleredgedups(g,op,seq)
<BR>determines if given sequence of labels determines
<BR>an edge-covering circuit on graph g.  options op is needed
<BR>for labels
<BR>returns -1 if not all edges covered or seq uses nonexisting edges
<BR>returns 0 if all edges covered with no dup
<BR>returns # of dups if covers all edges with duplications
<BR><h3><a name="graphsequenceishamiltonian">graphsequenceishamiltonian</a></h3>
function graphsequencishamiltonian(g,op,seq)
<BR>determines if given sequence of labels determines
<BR>a hamiltonian circuit on graph g.  options op is needed
<BR>for labels
<BR><h3><a name="graphgetpathlength">graphgetpathlength</a></h3>
graphgetpathlength(g,op,seq)
<BR>Given sequence seq of graph labels, determine the
<BR>length of the path on graph g
<BR>options needed for vertex labels
<BR><h3><a name="graphshortestpath">graphshortestpath</a></h3>
graphshortestpath(g,op,start,end,[type])
<BR>find shortest path on graph g from vertex start to end
<BR>returns array(shortest path,length of path)
<BR>for path,
<BR>type=0 returns labeledpath, like ABCD
<BR>type=1 returns array of vertex indices
<BR><h3><a name="graphcircuittostringans">graphcircuittostringans</a></h3>
graphcircuittostringans(gs,[lbl, start])
<BR>converts graph or array of graphs containing circuits to
<BR>a string of labels that can be used as an $answer.
<BR>lbl is an array of labels (defaults to A,B,C,etc.)
<BR>start is the index of the vertex to start the string circuits with
<BR><h3><a name="graphcircuittoarray">graphcircuittoarray</a></h3>
graphcircuittoarray(g,[start])
<BR>converts graph containing a circuit to an array
<BR>of vertices in circuit order
<BR><h3><a name="graphgetedges">graphgetedges</a></h3>
graphgetedges(g,op) 
<BR>gets list of edges in and not in graph
<BR>need op['labels'] set
<BR>return (goodedges,badedges)
<BR><h3><a name="graphgetedgesarray">graphgetedgesarray</a></h3>
graphgetedgesarray(g) 
<BR>gets array of edges in a graph
<BR>returns array of edges; each edge is array(startvert,endvert)
<BR><h3><a name="graphgettotalcost">graphgettotalcost</a></h3>
graphgettotalcost(g) 
<BR>gets total cost of all edges in a graph
<BR><h3><a name="graphadjacencytoprereqs">graphadjacencytoprereqs</a></h3>
graphadjacencytoprereqs(g,[options])
<BR>create incidence lists from adjacency matrix g
<BR>g[i][j] &gt; 0 if edge from i to j
<BR>outputs list where list[i] is array of vertices
<BR>  that lead to i.  Only intended for digraphs.
<BR><h3><a name="graphprereqtable">graphprereqtable</a></h3>
graphprereqtable(g,w,[op]) 
<BR>creates an HTML table showing the tasks in g, the task times in w, and
<BR>the tasks that must be completed first.
<BR>use $op['labels'] to provide array of labels, or ='letters' to use letters
<BR><h3><a name="graphadjacencytoincidence">graphadjacencytoincidence</a></h3>
graphadjacencytoincidence(g,[options])
<BR>create incidence lists from adjacency matrix g
<BR>g[i][j] &gt; 0 if edge from i to j
<BR>outputs list where list[i] is array of vertices
<BR>  that i leads to
<BR><h3><a name="graphincidencetoadjacency">graphincidencetoadjacency</a></h3>
graphincidencetoadjacency(list,[options])
<BR>create adjacency matrix g from incidence list
<BR>list is where list[i] is array of vertices
<BR>  that i leads to
<BR>outputs matrix g[i][j]=1 if edge from i to j
<BR><h3><a name="graphgetvalence">graphgetvalence</a></h3>
graphgetvalence(g,vert,[dir])
<BR>gets valence(degree) of vertex vert
<BR>if digraph, can use dir:
<BR>   0: indegree, 1: outdegree, 2: both (default)
<BR><h3><a name="graphmakesymmetric">graphmakesymmetric</a></h3>
graphmakesymmetric(g)
<BR>ensures that all edges are bidirectional.  
<BR><h3><a name="graphisconnected">graphisconnected</a></h3>
graphisconnected
<BR>checks if graph is connected
<BR><h3><a name="graphmaketable">graphmaketable</a></h3>
graphmaketable(g,[op])
<BR>makes a weights table based on a given graph
<BR><h3><a name="graphspringlayout">graphspringlayout</a></h3>
graphspringlayout(g,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a randomized spring layout engine.  Doesn't work great.
<BR>g is a 2-dimensional upper triangular matrix
<BR>g[i][j] &gt; 0 if vertices i and j are connected
<BR>not a digraph
<BR><h3><a name="graphcirclelayout">graphcirclelayout</a></h3>
graphcirclelayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a circular layout
<BR>g is a 2-dimensional upper triangular matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphcircledstarlayout">graphcircledstarlayout</a></h3>
graphcircledstarlayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a circular layout with the first vertex in the center of the circle
<BR>g is a 2-dimensional upper triangular matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphgridlayout">graphgridlayout</a></h3>
graphgridlayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a rectangular grid layout.  Could hide
<BR>some edges that connect colinear vertices
<BR>use options['wiggle'] = true to perterb off exact grid
<BR>g is a 2-dimensional matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphpathlayout">graphpathlayout</a></h3>
graphpathlayout(graph,[options])
<BR>draws a graph based on a graph incidence matrix
<BR>using a backflow to place the vertices in approximate
<BR>order of incidence.  Could hide
<BR>some edges that connect colinear vertices
<BR>use options['wiggle'] = true to perterb off exact grid
<BR>g is a 2-dimensional matrix
<BR>g[i][j] &gt; 0 if vertexes i and j are connected
<BR><h3><a name="graphprocessoptions">graphprocessoptions</a></h3>
internal function, not to be used directly
<BR><h3><a name="graphdrawit">graphdrawit</a></h3>
internal function, not usually used directly
<BR>can get called with graph matrix g, g[i][j] if vertex i has edge to j
<BR>pos is array where pos[i] = array(x,y) positions for vertices
<BR><h3><a name="graphcomparecircuits">graphcomparecircuits</a></h3>
graphcomparecircuits(A,B)
<BR>returns true or false
<BR>compares two circuits to see if they are the same, regardless of starting
<BR>vertex.  So "ABCDA" would be considered equivalent to "DCBAD"
<BR>can be used with the conditional answer type to score circuits. 
<BR><h3><a name="graphrandomgridschedule">graphrandomgridschedule</a></h3>
graphrandomgridschedule(n, m, p,[options])
<BR>draws a n by m grid of vertices.  Each pair of neighboring
<BR>and diagonal vertices has a p probabilility (0 to 1) of being connected
<BR>an end vertex is added
<BR>options['weights'] as an array of n*m elements will be used as weights.
<BR>options['weights'] as a single number will randomize weights from 1 to that
<BR>  value
<BR>if options['labels'] are used, "start" and "end" will be added automatically
<BR><h3><a name="graphdecreasingtimelist">graphdecreasingtimelist</a></h3>
graphdecreasingtimelist(g,w)
<BR>uses the scheduling priority list generated by the decreasing time list
<BR>algorithm
<BR>g is the graph
<BR>w is the array of task times
<BR><h3><a name="graphcriticaltimelist">graphcriticaltimelist</a></h3>
graphcriticaltimelist(g,w)
<BR>uses the scheduling priority list generated by the critical path algorithm
<BR>g is the graph
<BR>w is the array of task times
<BR><h3><a name="graphbackflow">graphbackflow</a></h3>
graphbackflow(g,[w]) 
<BR>computes longest-path algorithm on the graph g
<BR>g is a 2-dimensional matrix
<BR>g[i][j] &gt; 1 if vertexes i leads to j
<BR>This might give bad/weird results if graph has a circuit
<BR>the last vertex will be used as the destination vertex
<BR>w are weights for the vertices, if a scheduling digraph and 
<BR>tasks rather than edges have weights
<BR>returns array(dist,next) where
<BR>dist[i] is the longest dist to end, and
<BR>next[i] is the vertex next closest to the end
<BR><h3><a name="graphlistprocessing">graphlistprocessing</a></h3>
graphlistprocessing(g,t,L,p,[options])
<BR>calculates the list processing algorithm on p processors with priority list L
<BR>t is an array of task times
<BR>L is an array of indices into g showing the priority list
<BR>g is a 2-dimensional matrix
<BR>g[i][j] > 0 if vertexes i leads to j, where cost of task i is c
<BR>This might give bad/weird results if graph has a circuit
<BR>the last vertex will be used as the destination vertex; it should be the
<BR>last task on the priority list and have task time 0.
<BR>output is out[processor] = array of array(task, timestarted, tasklength)
<BR><h3><a name="graphscheduletaskinfo">graphscheduletaskinfo</a></h3>
graphscheduletaskinfo(schedule,n)
<BR>where schedule is the result of graphlistprocessing
<BR>and n is the task number (0 indexed)
<BR>returns array(processor assigned (0 indexed), task start, task time)
<BR><h3><a name="graphschedulecompletion">graphschedulecompletion</a></h3>
graphschedulecompletion(schedule)
<BR>where schedule is the result of graphlistprocessing
<BR>returns completion time of the schedule
<BR><h3><a name="graphscheduleidle">graphscheduleidle</a></h3>
graphscheduleidle(schedule,p)
<BR>where schedule is the result of graphlistprocessing
<BR>and p is the processor number (0-indexed)
<BR><h3><a name="graphscheduleproctasks">graphscheduleproctasks</a></h3>
graphscheduleproctasks(schedule,p,[oneindex])
<BR>return an array of the tasks the processor worked on, in order
<BR>set oneindex=true to add one to the last index to get task numbers
<BR><h3><a name="graphdrawschedule">graphdrawschedule</a></h3>
graphdrawschedule(sc,[width,height,names])
<BR>draws the schedule generated by graphlistprocessing
<BR>defaults to width=600,height=70*# of processors
<BR>can provide array of task names, or it will default to task numbers (starting at 1)
<BR><h3><a name="graphschedulelayout">graphschedulelayout</a></h3>
graphschedulelayout(g,w,pos,[op])
<BR>draws a schedule digraph 
<BR>g is the graph, w is an array of task times
<BR>pos is array where L[task number] = array(column,row (counting up from bottom))
<BR>use $options['labels'] to specify labels, or T1 - TN will be used
<BR><h3><a name="graphschedulemultchoice">graphschedulemultchoice</a></h3>
graphschedulemultchoice(g,t,L,p)
<BR>attempts to return 4 schedules which are different.  The first is the 
<BR>correct schedule based on the provided priority list L
<BR>